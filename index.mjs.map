{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport promotionRules from '@stdlib/ndarray-promotion-rules';\nimport safeCasts from '@stdlib/ndarray-safe-casts';\nimport resolveEnum from '@stdlib/strided-base-dtype-resolve-enum';\nimport resolveStr from '@stdlib/strided-base-dtype-resolve-str';\nimport format from '@stdlib/error-tools-fmtprodmsg';\n\n\n// FUNCTIONS //\n\n/**\n* Returns the intersection of two sorted lists.\n*\n* @private\n* @param {ArrayLikeObject} list1 - first sorted list\n* @param {ArrayLikeObject} list2 - second sorted list\n* @returns {ArrayLikeObject} result\n*\n* @example\n* var list1 = [ 'a', 'b', 'c', 'd' ];\n* var list2 = [ 'b', 'd', 'e' ];\n*\n* var out = intersection( list1, list2 );\n* // returns [ 'b', 'd' ]\n*/\nfunction intersection( list1, list2 ) {\n\tvar out;\n\tvar M;\n\tvar N;\n\tvar v;\n\tvar i;\n\tvar j;\n\tvar k;\n\n\tM = list1.length;\n\tN = list2.length;\n\n\tout = [];\n\tk = 0;\n\tfor ( i = 0; i < M; i++ ) {\n\t\tif ( k >= N ) {\n\t\t\tbreak;\n\t\t}\n\t\tv = list1[ i ];\n\t\tfor ( j = k; j < N; j++ ) {\n\t\t\tif ( v === list2[ j ] ) {\n\t\t\t\tk = j + 1;\n\t\t\t\tout.push( v );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn out;\n}\n\n/**\n* Resolves a list of data types to data type strings.\n*\n* @private\n* @param {ArrayLikeObject} dtypes - list of data types\n* @returns {(StringArray|Error)} data type strings (or an error)\n*\n* @example\n* var out = resolve( [ 1, 2, 3 ] );\n* // returns [...]\n*/\nfunction resolve( dtypes ) {\n\tvar out;\n\tvar dt;\n\tvar i;\n\n\tout = [];\n\tfor ( i = 0; i < dtypes.length; i++ ) {\n\t\tdt = resolveStr( dtypes[ i ] );\n\t\tif ( dt === null ) {\n\t\t\treturn new TypeError( format( '1MfJB', dtypes[ i ] ) );\n\t\t}\n\t\tout.push( dt );\n\t}\n\treturn out;\n}\n\n/**\n* Tests whether a provided array contains a specified value.\n*\n* @private\n* @param {Array} arr - input array\n* @param {*} value - search value\n* @returns {boolean} boolean indicating whether a provided array contains a specified value\n*/\nfunction contains( arr, value ) {\n\tvar i;\n\tfor ( i = 0; i < arr.length; i++ ) {\n\t\tif ( arr[ i ] === value ) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// MAIN //\n\n/**\n* Generates a list of binary interface signatures from strided array data types.\n*\n* ## Notes\n*\n* -   The function returns a strided array having a stride length of `3` (i.e., every `3` elements define a binary interface signature).\n* -   For each signature (i.e., set of three consecutive non-overlapping strided array elements), the first two elements are the input data types and the third element is the return data type.\n* -   All signatures follow type promotion rules.\n*\n* @param {Array} dtypes1 - list of supported data types for the first argument\n* @param {Array} dtypes2 - list of supported data types for the second argument\n* @param {Array} dtypes3 - list of supported data types for the output\n* @param {Options} [options] - options\n* @param {boolean} [options.enums=false] - boolean flag indicating whether to return signatures as a list of enumeration constants\n* @throws {TypeError} must provide recognized data types\n* @returns {Array} strided array containing binary interface signatures\n*\n* @example\n* var dtypes = [\n*     'float64',\n*     'float32',\n*     'int32',\n*     'uint8'\n* ];\n*\n* var sigs = signatures( dtypes, dtypes, dtypes );\n* // returns [ 'float32', 'float32', 'float32', ... ]\n*/\nfunction signatures( dtypes1, dtypes2, dtypes3, options ) {\n\tvar cache;\n\tvar casts;\n\tvar opts;\n\tvar tmp;\n\tvar out;\n\tvar dt1;\n\tvar dt2;\n\tvar dt3;\n\tvar t1;\n\tvar t2;\n\tvar t3;\n\tvar t4;\n\tvar M;\n\tvar N;\n\tvar i;\n\tvar j;\n\tvar k;\n\n\tif ( arguments.length > 3 ) {\n\t\topts = options;\n\t} else {\n\t\topts = {};\n\t}\n\t// Resolve the list of provided data types to data type strings:\n\tdt1 = resolve( dtypes1 );\n\tif ( dt1 instanceof Error ) {\n\t\tthrow dt1;\n\t}\n\tif ( dtypes2 === dtypes1 ) { // don't do work if we don't need to\n\t\tdt2 = dt1;\n\t} else {\n\t\tdt2 = resolve( dtypes2 );\n\t\tif ( dt2 instanceof Error ) {\n\t\t\tthrow dt2;\n\t\t}\n\t}\n\tif ( dtypes3 === dtypes1 ) { // don't do work if we don't need to\n\t\tdt3 = dt1;\n\t} else if ( dtypes3 === dtypes2 ) {\n\t\tdt3 = dt2;\n\t} else {\n\t\tdt3 = resolve( dtypes3 );\n\t\tif ( dt3 instanceof Error ) {\n\t\t\tthrow dt3;\n\t\t}\n\t}\n\t// Sort the list of return dtypes:\n\tdt3.sort();\n\n\t// Initialize a cache for storing the safe casts for promoted dtypes:\n\tcache = {};\n\n\t// Generate the list of signatures...\n\tM = dt1.length;\n\tN = dt2.length;\n\tout = [];\n\tfor ( i = 0; i < M; i++ ) {\n\t\tt1 = dt1[ i ];\n\t\tfor ( j = 0; j < N; j++ ) {\n\t\t\tt2 = dt2[ j ];\n\n\t\t\t// Resolve the promoted dtype for the current dtype pair:\n\t\t\tt3 = promotionRules( t1, t2 );\n\n\t\t\t// Check whether the dtype pair promotes...\n\t\t\tif ( t3 === -1 || t3 === null ) {\n\t\t\t\t// The dtype pair does not promote:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Check whether the promoted dtype is in our list of output dtypes...\n\t\t\tif ( contains( dt3, t3 ) ) {\n\t\t\t\tout.push( t1, t2, t3 );\n\t\t\t}\n\t\t\t// Retrieve the allowed casts for the promoted dtype:\n\t\t\tcasts = cache[ t3 ];\n\n\t\t\t// If a list of allowed casts is not in the cache, we need to resolve them...\n\t\t\tif ( casts === void 0 ) {\n\t\t\t\t// Resolve the list of safe casts for the promoted dtype:\n\t\t\t\tcasts = safeCasts( t3 );\n\n\t\t\t\t// Remove safe casts which are not among the supported output dtypes:\n\t\t\t\tcasts = intersection( dt3, casts.sort() );\n\n\t\t\t\t// Store the list of safe casts in the cache:\n\t\t\t\tcache[ t3 ] = casts;\n\t\t\t}\n\t\t\t// Generate signatures for allowed casts...\n\t\t\tfor ( k = 0; k < casts.length; k++ ) {\n\t\t\t\tt4 = casts[ k ];\n\t\t\t\tif ( t4 !== t3 ) {\n\t\t\t\t\tout.push( t1, t2, t4 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif ( opts.enums ) {\n\t\ttmp = [];\n\t\tfor ( i = 0; i < out.length; i++ ) {\n\t\t\ttmp.push( resolveEnum( out[ i ] ) );\n\t\t}\n\t\tout = tmp;\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default signatures;\n"],"names":["intersection","list1","list2","out","M","N","v","i","j","k","length","push","resolve","dtypes","dt","resolveStr","TypeError","format","contains","arr","value","signatures","dtypes1","dtypes2","dtypes3","options","cache","casts","opts","tmp","dt1","dt2","dt3","t1","t2","t3","t4","arguments","Error","sort","promotionRules","safeCasts","enums","resolveEnum"],"mappings":";;udA8CA,SAASA,EAAcC,EAAOC,GAC7B,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAOJ,IALAL,EAAIH,EAAMS,OACVL,EAAIH,EAAMQ,OAEVP,EAAM,GACNM,EAAI,EACEF,EAAI,EAAGA,EAAIH,KACXK,GAAKJ,GADSE,IAKnB,IADAD,EAAIL,EAAOM,GACLC,EAAIC,EAAGD,EAAIH,EAAGG,IACnB,GAAKF,IAAMJ,EAAOM,GAAM,CACvBC,EAAID,EAAI,EACRL,EAAIQ,KAAML,GACV,KACA,CAGH,OAAOH,CACR,CAaA,SAASS,EAASC,GACjB,IAAIV,EACAW,EACAP,EAGJ,IADAJ,EAAM,GACAI,EAAI,EAAGA,EAAIM,EAAOH,OAAQH,IAAM,CAErC,GAAY,QADZO,EAAKC,EAAYF,EAAQN,KAExB,OAAO,IAAIS,UAAWC,EAAQ,QAASJ,EAAQN,KAEhDJ,EAAIQ,KAAMG,EACV,CACD,OAAOX,CACR,CAUA,SAASe,EAAUC,EAAKC,GACvB,IAAIb,EACJ,IAAMA,EAAI,EAAGA,EAAIY,EAAIT,OAAQH,IAC5B,GAAKY,EAAKZ,KAAQa,EACjB,OAAO,EAGT,OAAO,CACR,CAiCA,SAASC,EAAYC,EAASC,EAASC,EAASC,GAC/C,IAAIC,EACAC,EACAC,EACAC,EACA1B,EACA2B,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAhC,EACAC,EACAE,EACAC,EACAC,EASJ,GANCmB,EADIS,UAAU3B,OAAS,EAChBe,EAEA,CAAA,GAGRK,EAAMlB,EAASU,cACKgB,MACnB,MAAMR,EAEP,GAAKP,IAAYD,EAChBS,EAAMD,OAGN,IADAC,EAAMnB,EAASW,cACKe,MACnB,MAAMP,EAGR,GAAKP,IAAYF,EAChBU,EAAMF,OACA,GAAKN,IAAYD,EACvBS,EAAMD,OAGN,IADAC,EAAMpB,EAASY,cACKc,MACnB,MAAMN,EAaR,IATAA,EAAIO,OAGJb,EAAQ,CAAA,EAGRtB,EAAI0B,EAAIpB,OACRL,EAAI0B,EAAIrB,OACRP,EAAM,GACAI,EAAI,EAAGA,EAAIH,EAAGG,IAEnB,IADA0B,EAAKH,EAAKvB,GACJC,EAAI,EAAGA,EAAIH,EAAGG,IAOnB,GANA0B,EAAKH,EAAKvB,IAMG,KAHb2B,EAAKK,EAAgBP,EAAIC,KAGA,OAAPC,EAuBlB,IAlBKjB,EAAUc,EAAKG,IACnBhC,EAAIQ,KAAMsB,EAAIC,EAAIC,QAMJ,KAHfR,EAAQD,EAAOS,MAQdR,EAAQ3B,EAAcgC,GAHtBL,EAAQc,EAAWN,IAGcI,QAGjCb,EAAOS,GAAOR,GAGTlB,EAAI,EAAGA,EAAIkB,EAAMjB,OAAQD,KAC9B2B,EAAKT,EAAOlB,MACA0B,GACXhC,EAAIQ,KAAMsB,EAAIC,EAAIE,GAKtB,GAAKR,EAAKc,MAAQ,CAEjB,IADAb,EAAM,GACAtB,EAAI,EAAGA,EAAIJ,EAAIO,OAAQH,IAC5BsB,EAAIlB,KAAMgC,EAAaxC,EAAKI,KAE7BJ,EAAM0B,CACN,CACD,OAAO1B,CACR"}